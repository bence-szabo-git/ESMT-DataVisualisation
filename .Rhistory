ggplot(df, aes(x = Date)) +
# You can shade the area between the upper and lower bands for emphasis
geom_ribbon(aes(ymin = LowBand, ymax = HighBand),
fill = "red", alpha = 0.1) +
geom_line(aes(y = Close, color = "Close"), size = 0.8) +
# You may see the SMA line plotted too
# geom_line(aes(y = SMA, color = "20-day SMA")) +
geom_line(aes(y = HighBand, color = "High Band"),
linetype = "dashed", size = 0.6) +
geom_line(aes(y = LowBand, color = "Low Band"),
linetype = "dashed", size = 0.6) +
labs(
title = "Bollinger Bands",
x = "Date",
y = "Price",
color = "Legend"
) +
theme_minimal() +
theme(
plot.title = element_text(size = 14, hjust = 0.5),
legend.position = "bottom"
) +
scale_color_manual(values = c(
"Close" = "black",
"High Band" = "red",
"Low Band" = "red"
# "20-day SMA" = "red"
))
## Subplots
# There are times when one plot just isn't enough. In this case we can create a subplot,
# and then plot on its axes. This generally calls for a different approach to ggplot2,
# so watch carefully!
# Create separate plots that we'll combine
# Adjust the space between the two plots using patchwork
# Plot the close prices on the first (top) subplot
p3 <- ggplot(df, aes(x = Date, y = Close)) +
geom_line(size = 0.8) +
labs(
title = "Close Price and Volume",
y = "Close Price"
) +
theme_minimal() +
theme(
axis.title.x = element_blank(),
axis.text.x = element_blank(),
plot.title = element_text(size = 14, hjust = 0.5)
)
# Plot the volume on the second (bottom) subplot
p4 <- ggplot(df, aes(x = Date, y = Volume)) +
geom_col(fill = "red", alpha = 0.7) +
labs(
x = "Date",
y = "Volume"
) +
theme_minimal() +
scale_y_continuous(labels = scales::comma_format())
# Combine plots vertically with different heights (3:1 ratio like the original)
combined_plot <- p3 / p4 +
plot_layout(heights = c(3, 1)) +
plot_annotation(theme = theme(plot.margin = margin(10, 10, 10, 10)))
# Display the combined plot
print(combined_plot)
# Alternative approach using gridExtra (commented out)
# library(gridExtra)
# grid.arrange(p3, p4, nrow = 2, heights = c(3, 1))
# Visualising TS Data
# In this script, we'll perform a visual analysis of a single stock. The ggplot2 package
# is one of the most popular in R for plotting. Let's first get our imports figured out
# first, since we have a good number of them now!
# Load required libraries
library(tidyverse)    # For data manipulation and ggplot2
library(lubridate)    # For date handling
library(slider)       # For rolling calculations
library(patchwork)    # For combining plots
# Now we can load the dataset, from a file called `GME_WSB.csv`. This data covers a
# particularly exciting two-year period for GameStop, a chain of video game retail stores.
# Read and prepare the data
df <- read_csv("Data/GME_WSB.csv") %>%
mutate(Date = ymd(Date)) %>%
arrange(Date) %>%
distinct() %>%
filter(!is.na(Date))
# View first few rows
head(df)
# Let's create our first simple plot. We'll use the `geom_line()` function to do this.
ggplot(df, aes(x = Date, y = Close)) +
geom_line() +
theme_minimal()
# That was easy, but its not very readable, or attractive. Let's try again.
# Styled plot with better formatting
ggplot(df, aes(x = Date, y = Close)) +
geom_line(aes(color = "Closing Price"), size = 0.8) +
labs(
title = "Gamestop in 2020-2022",
x = "Date",
y = "USD",
color = "Legend"
) +
theme_minimal() +
theme(
plot.title = element_text(size = 14, hjust = 0.5),
legend.position = "bottom"
) +
scale_color_manual(values = c("Closing Price" = "#2E86C1"))
# One of the most commonly plotted technical indicators is Bollinger Bands.
# They consist of two lines:
# - an upper band 2 standard deviations above the 20-day SMA
# - a lower band 2 standard deviations below the 20-day SMA
#
# When the bands are close, volatility is low. When they are far apart volatility is high.
# When the price is near the upper band the security may be overbought (ready for a decline),
# and when the price is near the lower band, the security may be oversold (ready for a jump).
# Calculate Bollinger Bands components
# Note: Assumes 'df' is a data frame with 'Date' and 'Close' columns containing stock price data
df <- df %>%
# STEP 1: Sort data chronologically
# Critical for time series analysis - calculations must be done in correct order
arrange(Date) %>%
# STEP 2: Add new columns with rolling calculations
mutate(
# Simple Moving Average (SMA) - 20-day rolling mean of closing prices
# .before = 19 means: current row + 19 previous rows = 20-day window
# .complete = TRUE means: only calculate when full 20 days are available (returns NA otherwise)
SMA = slider::slide_dbl(Close, mean, .before = 19, .complete = TRUE),
# Standard Deviation (Dev) - 20-day rolling standard deviation of closing prices
# Measures volatility/spread of prices around the moving average
# Uses same 20-day window as SMA for consistency
Dev = slider::slide_dbl(Close, sd, .before = 19, .complete = TRUE),
# Upper Bollinger Band - 2 standard deviations above the moving average
# Theoretical: ~97.5% of price movements should be below this line
# Used as resistance level or overbought indicator
HighBand = SMA + 2 * Dev,
# Lower Bollinger Band - 2 standard deviations below the moving average
# Theoretical: ~97.5% of price movements should be above this line
# Used as support level or oversold indicator
LowBand = SMA - 2 * Dev
)
# INTERPRETATION:
# - When price touches HighBand: potentially overbought (consider selling)
# - When price touches LowBand: potentially oversold (consider buying)
# - When bands are wide: high volatility period
# - When bands are narrow: low volatility period (potential breakout coming)
# - Price typically oscillates between the bands ~95% of the time
# BUSINESS APPLICATION:
# - Risk management: Set stop-losses at band levels
# - Entry/exit signals: Buy at lower band, sell at upper band
# - Volatility assessment: Band width indicates market uncertainty
# - Mean reversion strategy: Expect prices to return toward SMA
# Using the above features to calculate the bands and create the plot
ggplot(df, aes(x = Date)) +
# You can shade the area between the upper and lower bands for emphasis
geom_ribbon(aes(ymin = LowBand, ymax = HighBand),
fill = "red", alpha = 0.1) +
geom_line(aes(y = Close, color = "Close"), size = 0.8) +
# You may see the SMA line plotted too
# geom_line(aes(y = SMA, color = "20-day SMA")) +
geom_line(aes(y = HighBand, color = "High Band"),
linetype = "dashed", size = 0.6) +
geom_line(aes(y = LowBand, color = "Low Band"),
linetype = "dashed", size = 0.6) +
labs(
title = "Bollinger Bands",
x = "Date",
y = "Price",
color = "Legend"
) +
theme_minimal() +
theme(
plot.title = element_text(size = 14, hjust = 0.5),
legend.position = "bottom"
) +
scale_color_manual(values = c(
"Close" = "black",
"High Band" = "red",
"Low Band" = "red"
# "20-day SMA" = "red"
))
## Subplots
# There are times when one plot just isn't enough. In this case we can create a subplot,
# and then plot on its axes. This generally calls for a different approach to ggplot2,
# so watch carefully!
# Create separate plots that we'll combine
# Adjust the space between the two plots using patchwork
# Plot the close prices on the first (top) subplot
p3 <- ggplot(df, aes(x = Date, y = Close)) +
geom_line(size = 0.8) +
labs(
title = "Close Price and Volume",
y = "Close Price"
) +
theme_minimal() +
theme(
axis.title.x = element_blank(),
axis.text.x = element_blank(),
plot.title = element_text(size = 14, hjust = 0.5)
)
# Plot the volume on the second (bottom) subplot
p4 <- ggplot(df, aes(x = Date, y = Volume)) +
geom_col(fill = "red", alpha = 0.7) +
labs(
x = "Date",
y = "Volume"
) +
theme_minimal() +
scale_y_continuous(labels = scales::comma_format())
# Combine plots vertically with different heights (3:1 ratio like the original)
combined_plot <- p3 / p4 +
plot_layout(heights = c(3, 1)) +
plot_annotation(theme = theme(plot.margin = margin(10, 10, 10, 10)))
# Display the combined plot
print(combined_plot)
# Alternative approach using gridExtra (commented out)
# library(gridExtra)
# grid.arrange(p3, p4, nrow = 2, heights = c(3, 1))
# Multi Stock Analysis
# Let's work with some multiple stock panel data now. We'll use the same libraries as
# before, but we'll also introduce `corrplot` and additional ggplot2 extensions -
# other increasingly popular visualisation libraries in R. Again, we'll start with
# all of our imports.
library(tidyverse)    # For data manipulation and ggplot2
library(lubridate)    # For date handling
library(corrplot)     # For correlation matrix visualization (R equivalent of seaborn heatmap)
library(viridis)      # For color palettes
library(scales)       # For formatting axes
library(RColorBrewer) # Additional color palettes
# Let's load the panel data as normal.
df <- read_csv("Data/top_six_2020_2025.csv") %>%
mutate(DlyCalDt = dmy(DlyCalDt))  # dmy() for day-first date parsing
head(df)
# Let's say we wanted to visualise the closing prices of all the stocks in our data set.
# Reshaping our **long** data to **wide** makes plotting *really* straightforward.
#
# *(Note this follows ggplot2's philosophy of keeping data in long format, but we can
# also show the wide format approach)*
# Wide format approach (similar to pandas pivot)
pivot_df <- df %>%
select(DlyCalDt, Ticker, DlyClose) %>%
pivot_wider(names_from = Ticker, values_from = DlyClose) %>%
arrange(DlyCalDt)
print(pivot_df)
# Plot using wide format data - convert back to long for ggplot2
pivot_df %>%
pivot_longer(cols = -DlyCalDt, names_to = "Ticker", values_to = "DlyClose") %>%
ggplot(aes(x = DlyCalDt, y = DlyClose, color = Ticker)) +
geom_line(size = 0.8) +
labs(
title = 'Closing Prices of All Stocks',
x = "Date",
y = 'Price',
color = "Stock"
) +
theme_minimal() +
theme(
plot.title = element_text(size = 14, hjust = 0.5),
legend.position = "bottom"
) +
scale_y_continuous(labels = dollar_format()) +
scale_color_brewer(type = "qual", palette = "Set2")
# Alternative: Direct plotting from long format (more idiomatic R/ggplot2)
df %>%
ggplot(aes(x = DlyCalDt, y = DlyClose, color = Ticker)) +
geom_line(size = 0.8) +
labs(
title = 'Closing Prices of All Stocks (Long Format)',
x = "Date",
y = 'Price',
color = "Stock"
) +
theme_minimal() +
theme(
plot.title = element_text(size = 14, hjust = 0.5),
legend.position = "bottom"
) +
scale_y_continuous(labels = dollar_format()) +
scale_color_viridis_d()
# To understand the relationship between the daily returns of different stocks,
# we've previously used a correlation matrix. After finding daily returns and
# calculating the correlation with `cor()`, we can use `corrplot`'s `corrplot()`
# or ggplot2 to visualise it.
# Calculate daily returns and correlation matrix
correlation_matrix <- pivot_df %>%
select(-DlyCalDt) %>%
mutate(across(everything(), ~ (.x / lag(.x) - 1))) %>%  # pct_change equivalent
na.omit() %>%
cor()
print(correlation_matrix)
# Method 1: Using corrplot (most similar to seaborn heatmap)
corrplot(correlation_matrix,
method = "color",
type = "upper",
order = "hclust",
col = colorRampPalette(c("#053061", "#2166AC", "#4393C3", "#92C5DE",
"#D1E5F0", "#FFFFFF", "#FDDBC7", "#F4A582",
"#D6604D", "#B2182B", "#67001F"))(200),
tl.cex = 0.8,
tl.col = "black",
cl.cex = 0.8,
title = "Correlation Matrix of Daily Returns",
mar = c(0,0,2,0))
# Method 2: Using ggplot2 (more customizable)
correlation_df <- correlation_matrix %>%
as.data.frame() %>%
rownames_to_column("Stock1") %>%
pivot_longer(cols = -Stock1, names_to = "Stock2", values_to = "Correlation")
ggplot(correlation_df, aes(x = Stock1, y = Stock2, fill = Correlation)) +
geom_tile(color = "white", size = 0.5) +
scale_fill_gradient2(low = "#053061", mid = "white", high = "#67001F",
midpoint = 0, space = "Lab",
name = "Correlation\nCoefficient") +
labs(
title = 'Correlation Matrix of Daily Returns',
x = "Stock",
y = "Stock"
) +
theme_minimal() +
theme(
plot.title = element_text(size = 14, hjust = 0.5),
axis.text.x = element_text(angle = 45, hjust = 1),
axis.text.y = element_text(angle = 0, hjust = 1),
panel.grid = element_blank()
) +
coord_fixed() +
geom_text(aes(label = round(Correlation, 2)), color = "black", size = 3)
# Method 3: Simple correlation plot without annotations (cleaner look)
ggplot(correlation_df, aes(x = Stock1, y = Stock2, fill = Correlation)) +
geom_tile(color = "white", size = 0.5) +
scale_fill_viridis_c(name = "Correlation\nCoefficient") +
labs(
title = 'Correlation Matrix of Daily Returns (Viridis)',
x = "Stock",
y = "Stock"
) +
theme_minimal() +
theme(
plot.title = element_text(size = 14, hjust = 0.5),
axis.text.x = element_text(angle = 45, hjust = 1),
panel.grid = element_blank()
) +
coord_fixed()
library(sf)
library(usethis)
library(tidyverse)
library(rnaturalearth)
library(rnaturalearthdata)
library(patchwork)
# we will use the rnatural earth package to get a medium resolution
# vector map of world countries excluding Antarctica
world <- ne_countries(scale = "medium", returnclass = "sf") %>%
filter(name != "Antarctica")
st_geometry(world) # what is the geometry?
# CRS:            +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0
glimpse(world)
# all the magic happens in the last column, called 'geometry:'
# draw a map of the world. you really need just these two lines
ggplot(data = world) +
geom_sf()
# we can use different colours/fills, because why not
ggplot(data = world) +
geom_sf(fill="darkblue", colour="tomato")
ggplot(data = world) +
geom_sf(
mapping = aes(
geometry = geometry, # use Natural Earth World boundaries
fill = region_un     # fill colour= country’s region
),
colour = "white",      # white borders between regions
show.legend = FALSE    # no legend
)
ggplot(data = world) +
geom_sf(
mapping = aes(
geometry = geometry, #use Natural Earth World boundaries
fill = pop_est  #fill colour = population estimate
),
colour = "#fafafa",      # white borders between regions
)
# what happens if we change the crs/projection
base_map <- ggplot() +
geom_sf(data = world,
aes(
geometry = geometry, #use Natural Earth World boundaries
fill = region_un  #fill colour = country’s region
),
colour = "grey90",      # borders between regions
show.legend = FALSE    # no legend) +
)+
theme_minimal()+
NULL
base_map
# Longitude/latitude
map_lat_lon <- base_map +
coord_sf(crs = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_def") +
labs(title = "Longitude-latitude",
subtitle = 'crs = "+proj=longlat +ellps=WGS84"')
# Robinson
map_robinson <- base_map +
coord_sf(crs = "+proj=robin") +
labs(title = "Robinson",
subtitle = 'crs = "+proj=robin"')
# Mercator (ew)
map_mercator <- base_map +
coord_sf(crs = "+proj=merc") +
labs(title = "Mercator",
subtitle = 'crs = "+proj=merc"')
# Azimuthal Equidistant
map_azimuthal_equidistant <- base_map +
coord_sf(crs = "+proj=aeqd") +  # Gall Peters / Equidistant cylindrical
labs(title = "Azimuthal Equidistant",
subtitle = "crs = +proj=aeqd")
#use patchwork to arrange 4 maps in one page
(map_lat_lon / map_mercator) | ( map_robinson / map_azimuthal_equidistant)
library(googlesheets4)
library(sf)
library(opencage) # for geocoding addresses
library(usethis)
library(hrbrthemes) # hrbrmstr/hrbrthemes
library(googlesheets4)
library(sf)
library(opencage) # for geocoding addresses
library(usethis)
library(hrbrthemes) # hrbrmstr/hrbrthemes
source("~/Data_Viz/Data_Viz/R_flies/02_countries_e628.R", echo = TRUE)
Have you installed the "hrbrthemes" package yet? If not, you should install the package before loading it.
install.packages("hrbrthemes")
library(googlesheets4)
library(sf)
library(opencage) # for geocoding addresses
library(usethis)
library(hrbrmstr) # hrbrmstr/hrbrthemes
library(googlesheets4)
library(sf)
library(opencage) # for geocoding addresses
library(usethis)
library(hrbrthemes) # hrbrmstr/hrbrthemes
install.packages("hrbrmstr")
install.packages('https://cran.r-project.org/src/contrib/Archive/hrbrthemes/hrbrthemes_0.1.0.tar.gz', type='source', repos=NULL)
library(googlesheets4)
library(sf)
library(opencage) # for geocoding addresses
library(usethis)
library(hrbrthemes) # hrbrmstr/hrbrthemes
library(googlesheets4)
library(sf)
library(opencage) # for geocoding addresses
library(usethis)
#library(hrbrthemes) # hrbrmstr/hrbrthemes
library(tidyverse)
library(kableExtra)
library(rnaturalearth)
library(tmap)
library(tidygeocoder)
googlesheets4::gs4_auth() # google sheets authorisation
library(googlesheets4)
library(sf)
library(opencage) # for geocoding addresses
library(usethis)
#library(hrbrthemes) # hrbrmstr/hrbrthemes
library(tidyverse)
library(kableExtra)
library(rnaturalearth)
library(tmap)
library(tidygeocoder)
googlesheets4::gs4_auth() # google sheets authorisation
remotes::install_github("hrbrmstr/hrbrthemes")
library(googlesheets4)
library(sf)
library(opencage) # for geocoding addresses
library(usethis)
#library(hrbrthemes) # hrbrmstr/hrbrthemes
library(tidyverse)
library(kableExtra)
library(rnaturalearth)
library(tmap)
library(tidygeocoder)
googlesheets4::gs4_auth() # google sheets authorisation
#load countries_visited googlesheets
countries_e628 <- read_sheet("https://docs.google.com/spreadsheets/d/1M597P_NWZ88s_kLNL_pxaN2DVKa2Y_aQLfKvwvJYqKo/edit?usp=sharing
")
countries_e628 <- countries_e628 %>%
count(country, sort=TRUE)
geocoded <- countries_e628 %>%
mutate(
address_geo = purrr::map(country, geo, method = "osm")
) %>%
unnest_wider(address_geo)
geocoded %>%
kable()%>%  # print a table with geocoded addresses
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
# we will use the rnatural earth package to get a medium resolution
# vector map of world countries excl. Antarctica
world <- ne_countries(scale = "medium", returnclass = "sf") %>%
filter(name != "Antarctica")
st_geometry(world) # what is the geometry?
# CRS:            +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0
ggplot(data = world) +
geom_sf() + # the first two lines just plot the world shapefile
geom_point(data = geocoded, # then we add points
aes(x = long, y = lat),
size = 2,
colour = "#001e62") +
theme_void()
world_visited <- left_join(world, geocoded,  by=c("admin" = "country" )) %>%
mutate(visited = if_else (!is.na(lat), "visited", "not visited")
)
ggplot(world_visited)+
geom_sf(aes(fill=visited),
show.legend = FALSE)+    # no legend
scale_fill_manual(values=c('#f0f0f0', '#3182bd'))+
coord_sf(datum = NA) +
theme_void()+
labs(title="Where do E628 participants come from?")+
NULL
